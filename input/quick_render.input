# General parameters
model_type  = simulation  # type of model (simulation, formula)
num_threads = 4           # number of threads to use in parallel

# Output parameters
output_format = npz                      # format of output file (raw, npy, npz)
output_file   = output/quick_render.npz  # file to be (over)written with output data
output_camera = false                    # flag for saving camera details

# Checkpoint parameters
checkpoint_geodesic_save = false  # flag indicating geodesics should be saved
checkpoint_geodesic_load = false  # flag indicating geodesics should be loaded
checkpoint_sample_save   = false  # flag indicating simulation sampling should be saved
checkpoint_sample_load   = false  # flag indicating simulation sampling should be loaded

# Simulation parameters (only used if model_type == simulation)
simulation_file         = data/mock.athdf  # file containing Athena++ data dump if needed
simulation_multiple     = false            # flag for processing multiple files
simulation_coord        = sph_ks           # simulation coordinates (sph_ks, cart_ks)
simulation_m_msun       = 4.152e6          # black hole mass in solar masses
simulation_a            = 0.0              # dimensionless black hole spin
simulation_rho_cgs      = 1.0e-16          # unit code density in g/cm^3
simulation_kappa_name   = kappa            # name of variable containing electron entropy
simulation_interp       = false            # flag indicating interpolation should be used
simulation_block_interp = false            # flag indicating interpolation should cross blocks

# Camera parameters
camera_type       = plane  # type of camera (plane, pinhole)
camera_r          = 50.0   # KS radial coordinate r of camera in gravitational units
camera_th         = 60.0   # KS polar coordinate theta of camera in degrees (0/180 for N/S)
camera_ph         = 0.0    # KS azimuthal coordinate phi of camera in degrees
camera_urn        = 0.0    # contravariant KS normal r-velocity of camera
camera_uthn       = 0.0    # contravariant KS normal theta-velocity of camera (using radians)
camera_uphn       = 0.0    # contravariant KS normal ph-velocity of camera (using radians)
camera_k_r        = 1.0    # covariant KS r-momentum of received photons
camera_k_th       = 0.0    # covariant KS theta-momentum of received photons (using radians)
camera_k_ph       = 0.0    # covariant KS phi-momentum of received photons (using radians)
camera_rotation   = 0.0    # rotation of camera in degrees (0/90 for north up/left)
camera_width      = 100.0  # full width of image in gravitational units
camera_resolution = 256    # number of pixels per side

# Ray-tracing parameters
ray_flat        = true            # flag indicating ray tracing should assume flat spacetime
ray_terminate   = multiplicative  # termination condition (photon, multiplicative, additive)
ray_factor      = 1.005           # constant for terminate (only used for ray_terminate != photon)
ray_step        = 0.01            # ratio of maximum proper length of step to radial coordinate
ray_max_steps   = 3300            # maximum number of steps allowed for each geodesic
ray_max_retries = 25              # maximum number of times a step can fail
ray_tol_abs     = 1.0e-8          # absolute tolerance for taking full steps
ray_tol_rel     = 1.0e-8          # relative tolerance for taking full steps
ray_err_factor  = 0.9             # coefficient used to scale step size based on error
ray_min_factor  = 0.2             # minimum ratio of new to old step size
ray_max_factor  = 10.0            # maximum ratio of new to old step size

# Image parameters
image_light         = false     # flag indicating real image of radiation should be produced
image_frequency     = 2.3e11    # frequency of observation in Hz
image_normalization = infinity  # image_frequency location (camera [w/ velocity], infinity [rest])
image_polarization  = false     # flag indicating transport should be polarized
image_time          = false     # flag indicating image of geodesic times should be produced
image_length        = false     # flag indicating image of geodesic lengths should be produced
image_lambda        = false     # flag indicating image of affine path lengths should be produced
image_emission      = false     # flag indicating image of emission coefficients should be produced
image_tau           = false     # flag indicating image of optical depths should be produced
image_lambda_ave    = false     # flag indicating lambda-averaged images should be produced
image_emission_ave  = false     # flag indicating emission-averaged images should be produced
image_tau_int       = false     # flag indicating tau-integrated images should be produced

# Rendering parameters
render_num_images     = 1             # number of false-color renderings
render_1_num_features = 3             # image 1: number of features
render_1_1_quantity   = sigma         # image 1, feature 1: quantity to use
render_1_1_type       = fill          # image 1, feature 1: type (fill, thresh, rise, fall)
render_1_1_min        = 1.0           # image 1, feature 1: lower cutoff
render_1_1_max        = inf           # image 1, feature 1: upper cutoff
render_1_1_tau_scale  = 1.5e13        # image 1, feature 1: opacity in [0,1]
render_1_1_rgb        = 222,12,98     # image 1, feature 1: RGB colors in [0,255]
render_1_2_quantity   = beta_inverse  # image 1, feature 2: quantity to use
render_1_2_type       = thresh        # image 1, feature 2: type (fill, thresh, rise, fall)
render_1_2_thresh     = 1.0           # image 1, feature 2: threshold
render_1_2_opacity    = 0.2           # image 1, feature 2: opacity in [0,1]
render_1_2_rgb        = 133,197,38    # image 1, feature 2: RGB colors in [0,255]
render_1_3_quantity   = rho           # image 1, feature 3: quantity to use
render_1_3_type       = fill          # image 1, feature 3: type (fill, thresh, rise, fall)
render_1_3_min        = 2.0e-17       # image 1, feature 3: lower cutoff
render_1_3_max        = inf           # image 1, feature 3: upper cutoff
render_1_3_tau_scale  = 1.5e13        # image 1, feature 3: optical depth length scale
render_1_3_rgb        = 106,121,247   # image 1, feature 3: RGB colors in [0,255]

# Slow-light parameters (only used if model_type == simulation)
slow_light_on = false  # flag indicating slow light should be used

# Adaptive parameters
adaptive_max_level = 0  # maximum number of adaptive levels beyond root

# Plasma parameters (only used if model_type == simulation)
plasma_mu         = 0.5         # molecular weight of fluid in proton masses
plasma_ne_ni      = 1.0         # electrons per ion
plasma_model      = ti_te_beta  # electron temperature model (ti_te_beta, code_kappa)
plasma_rat_low    = 1.0         # ion-electron temperature ratio at zero plasma beta
plasma_rat_high   = 10.0        # ion-electron temperature ratio at infinite plasma beta
plasma_power_frac = 0.0         # fraction of electrons with power-law distribution
plasma_kappa_frac = 0.0         # fraction of electrons with kappa distribution

# Cut parameters
cut_rho_min          = -1.0   # if nonneg., cutoff in rho below which plasma is ignored
cut_rho_max          = -1.0   # if nonneg., cutoff in rho above which plasma is ignored
cut_n_e_min          = -1.0   # if nonneg., cutoff in n_e below which plasma is ignored
cut_n_e_max          = -1.0   # if nonneg., cutoff in n_e above which plasma is ignored
cut_p_gas_min        = -1.0   # if nonneg., cutoff in p_gas below which plasma is ignored
cut_p_gas_max        = -1.0   # if nonneg., cutoff in p_gas above which plasma is ignored
cut_theta_e_min      = -1.0   # if nonneg., cutoff in Theta_e below which plasma is ignored
cut_theta_e_max      = -1.0   # if nonneg., cutoff in Theta_e above which plasma is ignored
cut_b_min            = -1.0   # if nonneg., cutoff in B below which plasma is ignored
cut_b_max            = -1.0   # if nonneg., cutoff in B above which plasma is ignored
cut_sigma_min        = -1.0   # if nonneg., cutoff in sigma below which plasma is ignored
cut_sigma_max        = -1.0   # if nonneg., cutoff in sigma above which plasma is ignored
cut_beta_inverse_min = -1.0   # if nonneg., cutoff in 1/beta below which plasma is ignored
cut_beta_inverse_max = -1.0   # if nonneg., cutoff in 1/beta above which plasma is ignored
cut_omit_near        = false  # flag indicating near half of simulation should be omitted
cut_omit_far         = false  # flag indicating far half of simulation should be omitted
cut_omit_in          = -1.0   # if nonneg., radius inside of which simulation is omitted
cut_omit_out         = -1.0   # if nonneg., radius outside of which simulation is omitted
cut_plane            = false  # flag for domain being excluded beyond a certain plane

# Fallback parameters
fallback_nan = true  # flag indicating any fallback should result in NaN for that ray
